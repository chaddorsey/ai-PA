# 2-2 Health Check and Dependency Standardization

[Back to task list](./tasks.md)

## Description

Implement consistent health checks for all services and optimize service dependencies to improve startup reliability, monitoring, and orchestration. Focus on services currently missing health checks and optimizing dependency chains for faster, more reliable startup.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-09-20 05:45:00 | Created | N/A | Proposed | Task created following network unification success | AI_Agent |
| 2025-09-20 05:45:00 | Status Update | Proposed | InProgress | Beginning health check analysis and implementation | AI_Agent |
| 2025-09-20 06:15:00 | Status Update | InProgress | Review | Health checks added to 5 services, dependencies optimized, config standardized | AI_Agent |

## Requirements

### Functional Requirements
- [ ] Add health checks to all HTTP-based services
- [ ] Standardize health check patterns and timeouts
- [ ] Optimize service dependencies with `condition: service_healthy`
- [ ] Improve startup order and reliability
- [ ] Add restart policies where missing

### Technical Requirements
- [ ] Health checks must be lightweight and non-intrusive
- [ ] Consistent timeout and retry patterns across services
- [ ] Dependencies must reflect actual service communication needs
- [ ] Health checks should fail fast for faster recovery
- [ ] Validation scripts for testing health check functionality

## Implementation Plan

### 1. Current Health Check Analysis

Based on service analysis, current health check status:

#### ✅ Services WITH Health Checks
```yaml
letta:                 # HTTP health check on /v1/health
open-webui:           # HTTP health check  
supabase-meta:        # Healthy status confirmed
supabase-db:          # Database health check working
```

#### ❌ Services MISSING Health Checks
```yaml
n8n:                  # HTTP service at :5678 - needs health check
gmail-mcp:            # HTTP service at :7331 - needs health check  
slack-mcp-server:     # HTTP service at :3001 - needs health check
graphiti-mcp:         # HTTP service at :8000 - needs health check
neo4j:                # HTTP browser at :7474 - needs health check
supabase-rest:        # HTTP service - needs health check
supabase-auth:        # HTTP service - needs health check
supabase-realtime:    # WebSocket service - needs health check
cloudflared:          # Tunnel service - needs simple health check
```

### 2. Health Check Implementation Strategy

#### A. HTTP Services Health Checks
```yaml
# Standard HTTP health check pattern
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:PORT/health"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 40s
```

#### B. Database Services Health Checks  
```yaml
# Database connection health check
healthcheck:
  test: ["CMD", "pg_isready", "-U", "user", "-d", "dbname"]
  interval: 30s
  timeout: 5s
  retries: 5
  start_period: 30s
```

#### C. MCP Services Health Checks
```yaml
# MCP server health check (port check)
healthcheck:
  test: ["CMD", "nc", "-z", "localhost", "PORT"]
  interval: 30s
  timeout: 5s
  retries: 3
  start_period: 30s
```

### 3. Service Dependencies Optimization

#### Current Dependencies Analysis
```yaml
# Well-configured dependencies:
supabase-services → supabase-db ✅
letta → (network to supabase-db) ✅
graphiti-mcp → neo4j ✅
cloudflared → n8n ✅

# Missing explicit dependencies:
n8n → should depend on supabase-db
gmail → no dependencies (ok for MCP)
slack-mcp-server → no dependencies (ok for MCP)
```

#### Target Dependency Chain
```yaml
# Core infrastructure
supabase-db (foundation)
  ↓
# Database-dependent services  
supabase-rest, supabase-auth, supabase-realtime
n8n, letta
  ↓
# Secondary services
neo4j → graphiti-mcp
open-webui
MCP servers (gmail, slack-mcp-server)
  ↓
# External services
cloudflared (depends on n8n)
```

### 4. Implementation Steps

#### Step 1: Add Health Checks to HTTP Services

**N8N Health Check**
```yaml
n8n:
  # ... existing config ...
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:5678/healthz"]
    interval: 30s
    timeout: 10s
    retries: 3
    start_period: 60s  # N8N takes longer to start
```

**MCP Services Health Checks**
```yaml
gmail:
  # ... existing config ...
  healthcheck:
    test: ["CMD", "nc", "-z", "localhost", "7331"]
    interval: 30s
    timeout: 5s
    retries: 3
    start_period: 30s

slack-mcp-server:
  # ... existing config ...
  healthcheck:
    test: ["CMD", "nc", "-z", "localhost", "3001"]
    interval: 30s
    timeout: 5s
    retries: 3
    start_period: 30s

graphiti-mcp:
  # ... existing config ...
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
    interval: 30s
    timeout: 10s
    retries: 3
    start_period: 45s
```

**Neo4j Health Check**
```yaml
neo4j:
  # ... existing config ...
  healthcheck:
    test: ["CMD", "neo4j", "status"]
    interval: 30s
    timeout: 10s
    retries: 5
    start_period: 60s  # Neo4j startup is slow
```

#### Step 2: Optimize Service Dependencies

**Add health-based dependencies:**
```yaml
n8n:
  depends_on:
    supabase-db:
      condition: service_healthy

letta:
  depends_on:
    supabase-db:
      condition: service_healthy

graphiti-mcp:
  depends_on:
    neo4j:
      condition: service_healthy

cloudflared:
  depends_on:
    n8n:
      condition: service_healthy
```

#### Step 3: Standardize Restart Policies

```yaml
# Standard restart policy for all services
restart: unless-stopped

# Exception for development/optional services
restart: on-failure
```

#### Step 4: Environment Variable Cleanup

```yaml
# Add missing default values
OPENWEBUI_LOG_LEVEL: "${OPENWEBUI_LOG_LEVEL:-INFO}"

# Standardize debug patterns
SERVICE_DEBUG: "${SERVICE_DEBUG:-false}"
```

## Verification

### Success Criteria
- [ ] All HTTP services have appropriate health checks
- [ ] All services show "healthy" status in `docker compose ps`
- [ ] Service startup order is optimized and reliable
- [ ] Dependencies prevent premature service starts
- [ ] Health check timeouts are appropriate for each service type
- [ ] Restart policies are consistent across services

### Test Procedures

#### 1. Health Check Validation
```bash
# Test all services are healthy
docker compose ps --format table

# Check specific service health
docker inspect <service> --format='{{.State.Health.Status}}'

# Monitor health check logs
docker compose logs <service> | grep -i health
```

#### 2. Dependency Order Testing
```bash
# Test clean startup with dependencies
docker compose down
docker compose up -d

# Monitor startup order
docker compose logs -f --timestamps

# Verify no premature starts or connection failures
```

#### 3. Health Check Performance Testing
```bash
# Monitor health check overhead
docker stats --format table

# Test health check response times
time docker exec <service> curl -f http://localhost:PORT/health
```

#### 4. Failure Recovery Testing
```bash
# Test service recovery
docker compose stop <service>
docker compose start <service>

# Test unhealthy service behavior
# Verify dependent services wait appropriately
```

## Files Modified

### Configuration Files
- `docker-compose.yml` - Add health checks and optimize dependencies
- `scripts/validate-health.sh` - Health check validation script
- `scripts/test-startup-order.sh` - Dependency testing script

### Documentation Files
- `docs/delivery/2/health-check-implementation.md` - Health check patterns
- `docs/delivery/2/dependency-optimization.md` - Service dependency analysis
- `docs/delivery/2/startup-troubleshooting.md` - Troubleshooting guide

---

[Back to task list](./tasks.md)
